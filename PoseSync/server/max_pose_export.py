# -*- coding: utf-8 -*-
"""
3ds Max-friendly pose package export.

Exports:
- Structured pose JSON
- Manifest JSON
- Generated MAXScript to apply pose to scene nodes by name
"""

import datetime
import json
from pathlib import Path


def _fmt_float(v):
    return ("%.8f" % float(v)).rstrip("0").rstrip(".") if "." in ("%.8f" % float(v)) else ("%.8f" % float(v))


def _escape_ms_string(s):
    return str(s).replace("\\", "\\\\").replace("\"", "\\\"")


def _norm_quat_xyzw(q):
    if not isinstance(q, (list, tuple)) or len(q) != 4:
        return [0.0, 0.0, 0.0, 1.0]
    return [float(q[0]), float(q[1]), float(q[2]), float(q[3])]


def _norm_xyz(v):
    if not isinstance(v, (list, tuple)) or len(v) != 3:
        return [0.0, 0.0, 0.0]
    return [float(v[0]), float(v[1]), float(v[2])]


def _build_maxscript(structured_pose, apply_translation=True):
    bones = structured_pose.get("bones", [])
    lines = []
    pose_entries = []
    lines.append("-- Auto-generated by PoseSync")
    lines.append("-- rotation_space: %s" % structured_pose.get("rotation_space", "unknown"))
    lines.append("-- profile_name: %s" % structured_pose.get("profile_name", "unknown"))
    lines.append("")
    lines.append("global PoseSyncPoseData = #(")
    for b in bones:
        if not b.get("found"):
            continue
        rot = _norm_quat_xyzw((b.get("rotation") or {}).get("quat_xyzw", [0.0, 0.0, 0.0, 1.0]))
        trans = _norm_xyz((b.get("translation") or {}).get("xyz", [0.0, 0.0, 0.0]))
        use_t = bool(apply_translation and (b.get("translation") or {}).get("copied_from_source", False))
        node_name = _escape_ms_string(b.get("target", ""))
        pose_entries.append(
            '#("%s", #(%s, %s, %s, %s), %s, #(%s, %s, %s))'
            % (
                node_name,
                _fmt_float(rot[0]),
                _fmt_float(rot[1]),
                _fmt_float(rot[2]),
                _fmt_float(rot[3]),
                "true" if use_t else "false",
                _fmt_float(trans[0]),
                _fmt_float(trans[1]),
                _fmt_float(trans[2]),
            )
        )
    for i, entry in enumerate(pose_entries):
        suffix = "," if i < (len(pose_entries) - 1) else ""
        lines.append("    %s%s" % (entry, suffix))
    lines.append(")")
    lines.append("")
    lines.append("fn PoseSync_FindNodeCI nodeName =")
    lines.append("(")
    lines.append("    local t = toLower nodeName")
    lines.append("    for n in objects do")
    lines.append("    (")
    lines.append("        if (toLower n.name) == t do return n")
    lines.append("    )")
    lines.append("    undefined")
    lines.append(")")
    lines.append("")
    lines.append("fn PoseSync_ApplyEntry e =")
    lines.append("(")
    lines.append("    local nodeName = e[1]")
    lines.append("    local qarr = e[2]")
    lines.append("    local useT = e[3]")
    lines.append("    local tarr = e[4]")
    lines.append("    local n = PoseSync_FindNodeCI nodeName")
    lines.append("    if n == undefined then")
    lines.append("    (")
    lines.append('        format "PoseSync: missing node %\\n" nodeName')
    lines.append("        return false")
    lines.append("    )")
    lines.append("    local q = quat qarr[1] qarr[2] qarr[3] qarr[4]")
    lines.append("    local rotOk = false")
    lines.append("    local ctrlClass = (classof n.controller) as string")
    lines.append("    -- Biped bones usually require biped.setTransform; direct rotation assignment fails.")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append("        try")
    lines.append("        (")
    lines.append("            at time currentTime biped.setTransform n #rotation q false")
    lines.append("            rotOk = true")
    lines.append("        )")
    lines.append("        catch()")
    lines.append("    )")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append("        try")
    lines.append("        (")
    lines.append("            at time currentTime biped.setTransform n #rotation q true")
    lines.append("            rotOk = true")
    lines.append("        )")
    lines.append("        catch()")
    lines.append("    )")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append("        try (in coordsys parent n.rotation = q; rotOk = true) catch()")
    lines.append("    )")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append("        try (in coordsys local n.rotation = q; rotOk = true) catch()")
    lines.append("    )")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append("        try (n.rotation = q; rotOk = true) catch()")
    lines.append("    )")
    lines.append("    if not rotOk do")
    lines.append("    (")
    lines.append('        format "PoseSync: rotation failed for % (controller=%)\\n" nodeName (classof n.controller)')
    lines.append("    )")
    lines.append("    if useT then")
    lines.append("    (")
    lines.append("        local posOk = false")
    lines.append("        if not posOk do")
    lines.append("        (")
    lines.append("            try")
    lines.append("            (")
    lines.append("                at time currentTime biped.setTransform n #pos [tarr[1], tarr[2], tarr[3]] false")
    lines.append("                posOk = true")
    lines.append("            )")
    lines.append("            catch()")
    lines.append("        )")
    lines.append("        if not posOk do")
    lines.append("        (")
    lines.append("            try")
    lines.append("            (")
    lines.append("                at time currentTime biped.setTransform n #pos [tarr[1], tarr[2], tarr[3]] true")
    lines.append("                posOk = true")
    lines.append("            )")
    lines.append("            catch()")
    lines.append("        )")
    lines.append("        if not posOk do")
    lines.append("        (")
    lines.append("            try (n.position = [tarr[1], tarr[2], tarr[3]]; posOk = true) catch()")
    lines.append("        )")
    lines.append("        if not posOk do")
    lines.append("        (")
    lines.append('            format "PoseSync: translation failed for %\\n" nodeName')
    lines.append("        )")
    lines.append("    )")
    lines.append("    true")
    lines.append(")")
    lines.append("")
    lines.append("fn PoseSync_ApplyPoseData data =")
    lines.append("(")
    lines.append("    local applied = 0")
    lines.append("    for e in data do")
    lines.append("    (")
    lines.append("        if PoseSync_ApplyEntry e do applied += 1")
    lines.append("    )")
    lines.append('    format "PoseSync: applied % bones\\n" applied')
    lines.append("    applied")
    lines.append(")")
    lines.append("")
    lines.append("PoseSync_ApplyPoseData PoseSyncPoseData")
    lines.append("")
    return "\n".join(lines)


def export_max_pose_package(
    structured_pose,
    output_root,
    package_name="",
    include_source_joints=False,
    source_joints=None,
    include_raw=False,
    raw_payload=None,
    apply_translation=True,
):
    root = Path(output_root)
    root.mkdir(parents=True, exist_ok=True)

    if package_name:
        pkg_dir = root / str(package_name)
    else:
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        pkg_dir = root / ("posesync_max_pose_%s" % ts)
    pkg_dir.mkdir(parents=True, exist_ok=True)

    structured_pose_path = pkg_dir / "structured_pose.json"
    ms_path = pkg_dir / "apply_pose.ms"
    manifest_path = pkg_dir / "manifest.json"

    structured_pose_path.write_text(json.dumps(structured_pose, indent=2), encoding="utf-8")
    ms_text = _build_maxscript(structured_pose, apply_translation=bool(apply_translation))
    ms_path.write_text(ms_text, encoding="utf-8")

    source_joints_path = None
    raw_path = None
    if include_source_joints and isinstance(source_joints, dict):
        source_joints_path = pkg_dir / "source_joints.json"
        source_joints_path.write_text(json.dumps(source_joints, indent=2), encoding="utf-8")
    if include_raw and raw_payload is not None:
        raw_path = pkg_dir / "sam3d_raw.json"
        raw_path.write_text(json.dumps(raw_payload, indent=2), encoding="utf-8")

    manifest = {
        "format": "posesync_max_pose_package",
        "version": "1.0.0",
        "profile_name": structured_pose.get("profile_name"),
        "profile_version": structured_pose.get("profile_version"),
        "rotation_space": structured_pose.get("rotation_space"),
        "stats": structured_pose.get("stats", {}),
        "files": {
            "structured_pose": str(structured_pose_path),
            "apply_script_ms": str(ms_path),
            "source_joints": str(source_joints_path) if source_joints_path else "",
            "sam3d_raw": str(raw_path) if raw_path else "",
        },
    }
    manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    return {
        "package_dir": str(pkg_dir),
        "manifest_path": str(manifest_path),
        "structured_pose_path": str(structured_pose_path),
        "apply_script_path": str(ms_path),
        "source_joints_path": str(source_joints_path) if source_joints_path else "",
        "sam3d_raw_path": str(raw_path) if raw_path else "",
        "stats": structured_pose.get("stats", {}),
    }
